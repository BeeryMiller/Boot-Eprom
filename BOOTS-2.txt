TIFLOP
* now read sector 0 and test the type of floppy in the drive
* for sector i/o, use R0 for AU number, R1 for sector in AU
* and R2 for pointer to CPU RAM. Error code returned in R0
* and number of bytes read in R1
       CLR  R0
       CLR  R1
       LI   R2,SC0BUF
       BLWP @READSC      READ THAT SECTOR
       JEQ  CRSEC0       CAN'T READ THIS ONE SO GIVE MESSAGE
* HAVE READ SECTOR 0, SO NOW SEE IF ANY PARMS ARE DIFFERENT
* THAN EXPECTED
       LI   R2,SC0BUF
       MOVB @DSCPTK(R2),R3  GET NUMBER OF SECTORS PER TRACK
       SRL  R3,8
       MOV  R3,@SCPRTK   STORE IT IN SCPRTK FOR LATER USE
       MOVB @DTKPSD(R2),R4  NOW GET NUMBER OF TRACKS PER SIDE
       SRL  R4,8
USE40T MOV  R4,@FLPTRK   STORE NUMBER OF TRK PER SIDE
* NOW TEST IF THIS IS POSSIBLE 80 TRACKS ON THIS FLOPPY
       CI   R4,40
       JEQ  IS40TK       BRANCH IF NO PROBLEMS
* NOW TEST IF POSSIBLE 80 TRACK DRIVE
       CI   R4,80
       JEQ  IS80TK       BRANCH IF 80 TRACK FLOPPY
       LI   R4,40        ISN'T 40 OR 80, SO ASSUME 40
       JMP  USE40T

IS80TK MOV  R4,@FLPTRK   TEST IF IT THINKS IT IS AN 80 TRACK DRIVE
       MOV  R4,@T4080    TELL THEM ITS AN 80 TRACK DRIVE
THIN80
IS40TK
* NOW GET THE SECTOR POINTERS OUT OF SECTOR 1
       LI   R0,1
       CLR  R1
       LI   R2,SC1BUF
       BLWP @READSC      READ SECTOR 1
       JEQ  CRSEC1       BRANCH IF ERROR
*
* NOW SEE IF THERE IS A BOOT FILE
*
       LI   R8,SC1BUF    START SEARCH
********************************************************************************
*
*         FINDFL     -       THIS ROUTINE DOES A BINARY SEARCH TO GET A FILE
*                             GIVEN THE FILE POINTERS IN VDP RAM
*
*      INPUT -  R8 POINTS TO LOCATION IN VDPRAM OF POINTERS TO FCB'S ON DISK
*
*      USES REGISTERS R5-R10
*      ASSUMES FILE NAME TO FIND IS IN COMPARE BUFFER
*
*           ON RETURN, EQUAL BIT SET IF FOUND, IF NOT FOUND THEN NOT SET
*                      HOWEVER, IF NOT FOUND, THEN R2 POINTS TO LOCATION WHERE
*                        NEW POINTER IS TO BE STORED
*
*
*
*
*
*
********************************************************************************

       LI   R9,254       GET END POINTER IN R9
       A    R8,R9        NOW END POINTER IN R9
* ASSUME THAT R3 HAS THE SRAM BUFFER VALUE TO STORE FCB
       LI   R7,7         USE R7 AS ITERATION COUNTER FOR BINARY SEARCH (7 MAX)
BINSR  MOV  R8,R10       LOW POINTER IN R10
       A    R9,R10       GET MID POINT IN R10
       SRL  R10,2        DIVIDE BY 2 AND TRUNCATE
       SLA  R10,1
       AI   R10,>8000    ADJUST FOR SHIFTED OUT BIT
* NOW GET WORD POINTED TO IN R10
       MOV  *R10,R0           TEST IF POINTER IS ZERO
       JEQ  CLT               BRANCH IF YES
       LI   R2,FDRBUF
       MOV  R2,R6
       CLR  R1
       BLWP @READSC           READ SECTOR TO CPU MEMORY
       JEQ  CRSECX            BRANCH IF BAD READ
* NOW PERFORM COMPARE WITH DESIRED NAME
       LI   R5,BOTNAM
CNAMES C    *R5+,*R6+    TEST IF THE SAME
       JH   CGRT
       JL   CLT
       CI   R6,FDRBUF+10 TEST IF ALL 10 CHARACTERS COMPARED
       JNE  CNAMES       BRANCH IF NOT ALL 10 COMPARED YET
       JMP  NAMFND       ELSE LOAD FROM THIS FILE

CLT    MOV  R10,R9       SET UP NEXT CONDITION
       JMP  BINSR5

CGRT   MOV  R10,R8       SET UP NEXT CONDITION
BINSR5 DEC  R7           TEST IF THROUGH LOOP 7 TIMES
       JNE  BINSR        BRANCH IF NOT 7 TIMES THROUGH
*
* TO BE HERE, NO BOOT PROGRAM, SO GIVE A MESSAGE THAT SAYS SO
*    TRY TO SEE IF BOOTING FROM HORIZON RAM DISK
*
       MOV  @HRDISK,R0   TEST IF HORIZON RAM DISK BOOT
       JEQ  NOHR11       BRANCH IF NONE
       CLR  @HRDISK      NONE IS USABLE
       B    @NOHRRD      GO TO TRY THE HARD DISK

NOHR11 LI   R0,NOBOOT    NO BOOT PROGRAM FOUND
BADLO1 B    @BADLOD      TELL THEM ABOUT IT

BADOP7 LI   R0,WRGTYP    WRONG TYPE FILE SO TELL THEM
       JMP  BADLO1

CRSEC0
CRSEC1
CRSECX
REDDER LI   R0,READER
       JMP  BADLO1

NAMFND
*
* FOUND FILE NAME SO LOAD IT IN CPU RAM
* FDR IS IN FDRBUF, JUST READ ALL SECTORS GIVEN IN ALLOCATION OF FCB
*
*      LOAD FILE THE PART THAT ACTUALLY MOVES DATA TO THE DISK
*      REGISTER USAGE
*      R0
*      R1
*      R2
*      R3
*      R4   PAGE OF RAM
*      R5   LOAD POINTER IN RAM
*      R6   POINTER TO BUFFER PAIR IN FDR
*      R7   STARTING SECTOR IN CLUSTER
*      R8   ACTUAL NUMBER OF SECTORS IN CLUSTER
*      R9   ACTUAL NUMBER OF SECTORS READ FROM CLUSTER
********************************************************************************
LOADFI
* FIRST TEST IF FILE IS A PROGRAM FILE
       LI   R6,FDRBUF
       MOVB @DFSTF(R6),R2
       SLA  R2,8                TEST PROGRAM FLAG
       JNC  BADOP7       BRANCH IF NOT A PGM FILE
ISPGFI AI   R6,DPTRS     POINT TO FIRST SET OF FILE CLUSTERS
       CLR  R4           START LOAD ON PAGE 0 OF RAM
       SETO R9
       MOV  R9,R8        MAKE SURE THEY ARE EQUAL
SETPGG MOVB R4,@LODPAG   SET LOAD PAGE

       LI   R5,RAMBUF    LOAD ADDRESS START
********************************************************************************
*
*      ROUTINE TO GET NEXT SECTOR LOCATION FOR LOAD AND SAVE
*
********************************************************************************
SETSEC INC  R7                GET NEXT CONTIGUOUS SECTOR
       C    R8,R9             HAVE WE EXHAUSTED THIS CLUSTER?
       JNE  SETSE1            NOT YET
       CI   R6,FDRBUF+256
       JHE  LODDON            BRANCH IF COMPLETE
       MOVB *R6+,R7           LSB OF LOW POINTER
       SRL  R7,8              RIGHT JUSTIFY
       MOVB *R6,R7            MSB OF LOW AND LSB OF HIGH
       ANDI R7,>0FFF          STRIP OFF LSB OF HIGH
       JEQ  LODDON            BRANCH IF LOAD COMPLETE
       MOVB *R6+,R8           PUT IN LSB OF R2
       SRL  R8,8
       MOVB *R6+,R8           NOW MSB
       SRL  R8,4
SETSE1 INC  R9
       MOV  R7,R0
       CLR  R1
       MOV  R5,R2


       BLWP @READSC      GET THIS SECTOR AND PUT TO CPU RAM
       JEQ  REDDER       BRANCH IF READ DATA ERROR
       A    R1,R5        ADD NUMBER OF BYTES READ THIS TIME
       CI   R5,ENDRBF    ARE WE AT THE END OF THIS PAGE?
       JNE  SETSEC       NO, SO CONTINUE
* AT END SO MAP IN NEW PAGE AND START THIS ONE OVER AGAIN
       AI   R4,>0100
       JMP  SETPGG
       PAGE
LODDON
*  NOW TO MAP IN THIS DATA IN RAM AT >0000 AND BLWP THERE
* WE AT RUNNING OUT OF 0 TO >1FFF SO LOAD 0-7 IN MAP AND BLWP @0
       SBZ  0                 TURN OFF LOAD CARD

********************************************************************************
*      LI   R2,>2000          LOAD THE DEBUGGER IN AT E000
*      LI   R3,>E000
*LODDO1 MOV  *R2+,*R3+
*      CI   R3,>F000
*      JNE  LODDO1
********************************************************************************
*      LI   R2,>0203
*      LI   R3,MAP29          SET UP MEMORY >4000 TO >FFFF
*LODDO1 MOV  R2,*R3+
*      AI   R2,>0202          NEXT VALUE FOR MAPPER
*      CI   R3,MAP09+8
*      JNE  LODDO1

       LWPI >F000
       LI   R14,STUPST
       LI   R15,>F080
LODDO2 MOV  *R14+,*R15+
       CI   R14,STUPEN        IS IT ALL LOADED
       JNE  LODDO2
       B    @>F080
STUPST CLR  @MAP09            SET UP CORRECT PAGES
*      BL   @>E000            START UP DOS
       BLWP @0
STUPEN EQU  $

FINDEN
* THIS ROUTINE WILL TRY TO FIND IN THE DSR'S THE STRING POINTED TO
* BY THE CALLING R0

       MOV   *R14+,R5         GET INDEX INTO LINKAGE

       LI    R12,>1000

DLOOP7 BL    @DLOOP9          TRY TO FIND IT IN THIS CRU
       AI    R12,>0100
       CI    R12,>2000
       JNE   DLOOP7
DLOOP5 SOCB  @HEX20,R15       SET EQ BIT IN CALLING WORKSPACE
       RTWP

DLOOP9 SBO   >00
       SZCB  @HEX20,R15       RESET EQ BIT
       MOV   *R13,R0          GET THE POINTER TO CHAR LENGTH
       MOVB  *R0+,R1          GET THE LENGTH
       LI    R2,VALDSR        POINT TO DSR BYTE
       CB    *R2,@HEXAA       IS IT A VALID DSR?
       JNE   DLOOP2           NO IT ISN'T
       A     R5,R2            ADD IN OFFSET
       JMP   DLOOP8
DLOOP3 MOV   R10,R2           RECALL NEXT POINTER VECTOR
DLOOP8 MOV   *R2,R2           IS THE VECTOR ZERO?
       JEQ   DLOOP2           YES, SO TRY NEXT CARD
       MOV   R2,R10           SAVE NEXT POINTER VECTOR FOR NEXT TIME
       INCT  R2
       MOV   *R2+,R9          GET ENTRY FOR THIS NAME
       CB    R1,*R2+
       JNE   DLOOP3
       MOV   R1,R3
       SRL   R3,8
       MOV   R0,R6
DLOOP4 CB    *R6+,*R2+
       JNE   DLOOP3
       DEC   R3
       JNE   DLOOP4
*
* TO BE HERE, NAME IS FOUND AND ENTRY VECTOR IS IN R9, CRU BASE IN R12
*
       MOV   R9,@SAVR9       SAVE FOR LATER USE
       MOV   R12,@SAVR12     SAVE FOR LATER USE
       RTWP

DLOOP2 SBZ   0                TURN OFF CARD
       RT                     RETURN TO CALLER

* NOW ENTRY FOR JUST ONE CRU LOCATION
FINCR1 MOV   *R14+,R5         GET OFFSET
       BL    @DLOOP9          TRY TO FIND IT
       JMP   DLOOP5           DIDN'T SO TELL CALLER
